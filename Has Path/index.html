<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
     <title>Has Path

    </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js" integrity="sha512-GZ1RIgZaSc8rnco/8CXfRdCpDxRCphenIiZ2ztLy3XQfCbQUSCuk8IudvNHxkRA3oUg6q0qejgN/qqyG1duv5Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ext-language_tools.min.js" integrity="sha512-8qx1DL/2Wsrrij2TWX5UzvEaYOFVndR7BogdpOyF4ocMfnfkw28qt8ULkXD9Tef0bLvh3TpnSAljDC7uyniEuQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Asap:ital,wght@1,500&family=Fredoka+One&family=Marck+Script&family=Merienda:wght@700&family=Parisienne&family=Source+Code+Pro:wght@600&family=Varela+Round&display=swap" rel="stylesheet">
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/highlight.js@11.2.0/styles/monokai.css"
    />
  <link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300&family=Source+Code+Pro:wght@300&family=Spartan:wght@500&display=swap" rel="stylesheet">
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
      integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link rel="stylesheet" href="style.css">
   <!--  <link rel="stylesheet" href="query.css"> -->


  </head>
  <body>
  <div class="article1">
    <div class="article-1-outerbox">
        <div class="Circles hide-on-med-and-down">
          <div class="c1"></div>
          <div class="c2"></div>
        </div>
        <div class="topic-name">
            <p>Has Path
            </p> 
        </div>
        <a class="ca3-scroll-down-link ca3-scroll-down-arrow " data-ca3_iconfont="ETmodules" data-ca3_icon="">
            <i class="fa fa-chevron-down"></i>
        </a>
        <br><br><br><br>
        <div class="qoute">
            <br><br>
            <p>
              “Well done is better than well said.”<br>  — Benjamin Franklin
             </p>
            
            <i class="fa fa-quote-right qoute-icon"></i>
        </div>
    </div>
    <div class="question-logo"><i class="fa fa-quora"></i></div>
    <div class="ques-info">Has Path    </div>
    <div class="article-info">
        <div class="article-divider" style="margin-top:0px ;"></div>
        <div class="article-content">
          <div class="content">
            <p>Welcome Back Readers! </p>
            <p>We hope that you understood the<b> Introduction to Graph and its Representation. </b> </p><br>
            <p>Moving further, in this article we will discuss about the problem based on the Graph i.e. <b>Has Path.</b> </p>
            <br>
            <p>So we can get a hint from the name of the problem that we need to check whether there is a path between 2 given vertices of the graph. 
              Prerequisite for this problem is the Flood Fill problem which we did in Recursion. If you have already gone through that problem then this problem will be very easy for you to understand.
            </p>
            <p>Recursion. If you have already gone through that problem then this problem will be very easy for you to understand.
            </p>
            <p>Before you move any further, it is advised that you give this problem a fair try.</p>
            
            <p>Let’s now jump to the problem!</p>
            <p><b>Important Links :</b> <a href="https://www.pepcoding.com/resources/online-java-foundation/graphs/has-path-official/ojquestion">Problem Link</a>, <a href="https://youtu.be/mlnnJd9k7oE" target="_blank">Question Video</a> , <a href="https://youtu.be/mlnnJd9k7oE" target="_blank">Solution Video</a> </p>
            <div class="content">
              <p>Understanding the problem:
              </p>
              <p>In this problem you are given a graph, a source vertex and a destination vertex.
              </p>
              <p>
                <b>All you have to do is to find if a path exists between src and dest. If it does, print true.</b>>
              </p>
              <p>Input is managed for you.
             </p>
              <p>If you are finding it difficult to understand then we recommend you to watch the question video of this topic. I am sure that question will get much clearer once you watch it.
              </p>
              <div class="youtube-video">
                <iframe width="560" height="315" src="https://www.youtube.com/embed/mlnnJd9k7oE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
              </div>
             </div>
          </div>
        </div>  
        <div class="approach" id="approach">
          <div class="sub-heading-1">Approach :</div>
            <div class="content">
              <ul>
              <li>The problem here is to check whether there is any path present between src and dest. To solve this problem we will use Recursion.
              </li>
              <pliWe know that if there is a path between src vertex and dest vertex then there must also exist a path between src’s neighbor vertex and dest vertex too. 
            </li>
                <li>So we can develop some expectation and faith for this problem.

                </li>
                <li> <b>The expectation </b> from the hasPath(src, dest) function is that it will return us a Boolean value, indicating whether the path exists between src and dest.
                </li>
                <li>Keeping <b>the faith</b>> on the recursive call, hasPath(nbr, dest), that it works perfectly and will tell us whether there exists a path between src’s neighbor and dest vertex.
                </li>
                <li>And <b> meet this expectation with faith </b> by trusting the faith’s result and returning the same result. 
                </li>
                <li>If hasPath(nbr, dest) returns false then no path exists between  nbr and dest. So, it implies that no path exists between src and dest too.
                  And if it returns true then it means path exists between nbr and dest which means path also exists between src and dest.
                </li>
                  <li><b>And if src has n number of neighbors then we call hasPath() for each of the neighboring vertex unless a true is returned,</b> and if true is received through any call then the further iterations are halted and true is returned.
                  </li>
                    <li><b>And the base case for this function will be when src becomes equal to dest. It means we have reached our destination and therefore we return true.
                    </b></li>
                    <li>But if we notice, as this is a recursive function so we can get to see some redundant calls. </li>
                    <li>As src will make recursive calls to each of its neighbors, suppose that it made the first call to its neighbor 1, nbr1. So now this nbr1 will further make calls to each of its neighbors. 
                    </li>
                    <li>And not to forget, src is also one of nbr1’s neighbors. So src will again make a recursive call to its neighbor and first of all nbr1 will be called.</li>
                    <li>And it will give us a run time error of stack overflow.
                    </li>
                    <li>So, to handle this situation, we make use of the Boolean array, visited, which is already present in the signature of the hasPath() function in the code editor.
                    </li>
                    <li>Every time we enter the hasPath() function corresponding to a certain src, we update the visited array’s src index value to true. 
                    </li>
                    <li>And before making a call for any neighbor, we first check for the corresponding value of this neighbor's visited array.
                    </li>
                    <li>And make a call only if it’s false. As it implies that this vertex is being visited for the first time. </li>
              </ul>
                    <div class="content">
                <p>Let’s code this:</p>
              
              </div>
            </div>
        <div class='codeEditor' id=>
            <div class='editorialCode'>
              public static boolean hasPath(ArrayList<Edge>[] graph, int src, int dest, boolean[] visited) {
                //base case
                if (src == dest)
                   return true;
                //setting the value corresponding to src in visited as true.
                visited[src] = true;
                //applying for loop to access each neighbor of src
                for (Edge e : graph[src]) {
                   //checking whether this neighbor has been visited or not.
                   if (!visited[e.nbr]) {             
                      //if not than a recursive call is made to this neighbor and result is stored 
                      boolean nbrHasPath = hasPath(graph, e.nbr, dest, visited);
                      //if result is true than true is returned. 
                      if (nbrHasPath)
                         return true;
                   }
                }
                //if control reaches this point than it means that none of the neighbor has a path
                //to reach the destination, so we false is returned.
                return false;
             }
          
          </div>
          <pre class='output'>
          </pre>
          <span type='text' class='language' style='width:40%;margin-right:5%'>java</span>;
          <span type='text' style='width:40%' class='canRunCode' name='canRunCode'>true</span>";
         </div>
          <div class="content">
            <p>Yes, that looks perfect!!
            </p>
            <!-- <div class="youtube-video">
              <iframe width="560" height="315" src="https://www.youtube.com/embed/taL2G6jDLog" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
          </div> -->
            <p>Let’s take an example and dry run this code.</p>
              <div class="img"><img class="articleImages" name="hase_path_1.png" alt="img" /></div>
            <p>In the above figure, you can see graph representation corresponding to the Graph, Array List. Let the source be 0 and destination be 6.
            </p>

            <div class='codeEditor' id=>
              <div class='editorialCode'>
                public static boolean hasPath(ArrayList<Edge>[] graph, int src, 
                  int dest, boolean[] visited) {
                     if (src == dest)                   //1
                        return true;
                   
                     visited[src] = true;               //2
                     for (Edge e : graph[src]) {        //3
                        if (!visited[e.nbr]) {          //4
                           boolean nbrHasPath = hasPath(graph, e.nbr, dest, visited);  //5
                           if (nbrHasPath)              //6
                              return true;
                        }
                     }
                     return false;                      //7
                   }
               
            
            </div>
            <pre class='output'>
            </pre>
            <span type='text' class='language' style='width:40%;margin-right:5%'>java</span>;
            <span type='text' style='width:40%' class='canRunCode' name='canRunCode'>true</span>";
           </div>
            <p><b>Statement-1 is false for source 0. So control jumps to statement-2 and the value at index 0 is set true in the visited array.
            </b>
            </p>
            <p>Then using a for loop, a recursive call to 0’s neighbor is made. First neighbor is 1.
            </p>
            <p>Then we check whether 1 has been visited earlier or not. 1 has not been visited. Therefore, <b>a recursive call is made to hasPath(1, 6).</b>

            </p>
            <div class="img"><img class="articleImages" name="hase_path_2.png" alt="img" /></div>
           <p><b>Statement-1 is false for source 1. So control jumps to statement-2 and the value at index 1 is set true in the visited array.
          </b></p>
          <ul>
            <li>
              Then using a for loop, a recursive call to 1’s neighbor is made. First neighbor is 0.
            </li>
            <li>Then we check whether 0 has been visited earlier or not. 0 has been visited therefore we move to the next neighbor of 1 i.e. 2 in this case.
            </li>
            <li>Then we check whether 2 has been visited earlier or not. 2 hasn’t been visited, therefore hasPath(2, 6) will be called.
            </li>
            <li><b>Statement-1 is false for source 2. So control jumps to statement-2 and the value at index 2 is set true in the visited array.
            </b></li>
            <li>Then using a for loop, a recursive call to 2’s neighbor is made. First neighbor is 1.
            </li>
            <li>Then we check whether 1 has been visited earlier or not. 1 has been visited, therefore we move to the next neighbor of 2 i.e. 3 in this case.
            </li>
            <li>Then we check whether 3 has been visited earlier or not. 3 has not been visited, so hasPath(3, 6) will be called.
            </li>
            <li><b>Statement-1 is false for source 3. So control jumps to statement-2 and the value at index 3 is set true in the visited array.
            </b></li>
            <li>Then using a for loop, a recursive call to 3’s neighbor is made. First neighbor is 0.
            </li>
            <li>Then we check whether 2 has been visited earlier or not. 2 has been visited, therefore we move to the next neighbor of 3 i.e. 4 in this case.</li>
            <li>Then we check whether 4 has been visited earlier or not. 4 hasn’t been visited, therefore hasPath(4, 6) will be called.
            </li>
            <li>Statement-1 is false for source 4. So control jumps to statement-2 and the value at index 4 is set true in the visited array.
            </li>
            <li>Then using a for loop, a recursive call to 4’s neighbor is made. First neighbor is 3.
            </li>
            <li>Then we check whether 3 has been visited earlier or not. 3 has been visited, therefore we move to the next neighbor of 4 i.e. 5 in this case.
            </li>
            <li>We check whether 5 has been visited earlier or not. 5 hasn’t been visited, so hasPath(5, 6) will be called.
            </li>
            <li><b>Statement-1 is false for source 5. So control jumps to statement-2 and the value at index 5 is set true in the visited array.
            </b></li>
            <li>Then using a for loop, a recursive call to 5’s neighbor is made. First neighbor is 4.
            </li>
            <li>Then we check whether 4 has been visited earlier or not. 4 has been visited, therefore we move to the next neighbor of 5 i.e. 6 in this case.
            </li>
            <li>Then we check whether 6 has been visited earlier or not. 6 hasn’t been visited, therefore hasPath(6, 6) will be called.
            </li>
            <li>Statement-1 is true for source 6. Therefore ‘true’ is returned.
            </li>
          </ul>
          </div>
        

        <div class="analysis">
          <div class="sub-heading-1">Complexities:</div>
            <div class="sub-heading-2">Time Complexity: O(V+E)

            </div>
            <div class="content">
              <p><b>Where V is the number of vertices and E is the number of edges. In the worst case, all the vertices and all the edges will be travelled.
 
              </b></p>
              <p>The time complexity of the while loop (k log(k)).Which sum up to O(n log(k)).
              </p>
            </div>
            <div class="sub-heading-2">Space Complexity: O(V)
            </div>
            <div class="content">
              <p><b>It will be the height of the recursion stack, which can be O(V) at max.

              </b></p>
            </div>
        </div> 

        <div class='codeEditor' id=>
          <div class='editorialCode'>
            import java.io.*;
            import java.util.*;
             
            public class Main {
               static class Edge {
                  int src;
                  int nbr;
                  int wt;
             
                  Edge(int src, int nbr, int wt) {
                     this.src = src;
                     this.nbr = nbr;
                     this.wt = wt;
                  }
               }
             
               public static void main(String[] args) throws Exception {
                  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
             
                  int vtces = Integer.parseInt(br.readLine());
                  ArrayList< Edge>[] graph = new ArrayList[vtces];
                  for (int i = 0; i < vtces; i++) {
                     graph[i] = new ArrayList<>();
                  }
             
                  int edges = Integer.parseInt(br.readLine());
                  for (int i = 0; i < edges; i++) {
                     String[] parts = br.readLine().split(" ");
                     int v1 = Integer.parseInt(parts[0]);
                     int v2 = Integer.parseInt(parts[1]);
                     int wt = Integer.parseInt(parts[2]);
                     graph[v1].add(new Edge(v1, v2, wt));
                     graph[v2].add(new Edge(v2, v1, wt));
                  }
             
                  int src = Integer.parseInt(br.readLine());
                  int dest = Integer.parseInt(br.readLine());
             
                  boolean[] visited = new boolean[vtces];
                  boolean flag = hasPath(graph, src, dest, visited);
                  System.out.println(flag);
               }
             
               public static boolean hasPath(ArrayList< Edge>[] graph, int src, int dest, boolean[] visited) {
                  if (src == dest) 
                     return true;
                
                  visited[src] = true;
                  for (Edge e : graph[src]) {
                     if (!visited[e.nbr]) {
                        boolean nbrHasPath = hasPath(graph, e.nbr, dest, visited);
                        if (nbrHasPath)
                           return true;
                     }
                  }
                  return false;
            }
             
            }
            
        
        </div>
        <pre class='output'>
        </pre>
        <span type='text' class='language' style='width:40%;margin-right:5%'>java</span>;
        <span type='text' style='width:40%' class='canRunCode' name='canRunCode'>true</span>";
       </div>
       <div class="content">
         <p>We hope that this article was helpful. If somehow you are still finding it difficult to understand this problem, then we advise you to watch our video lecture of this problem. 
        </p>
        <div class="youtube-video">
          <iframe width="560" height="315" src="https://www.youtube.com/embed/mlnnJd9k7oE?start=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </div>
        <p>Trust me it would get much easier after you have watched the solution video.
          You can contact us via our website. Doubts, suggestions and feedback are always welcome.
          </p>
          <p>It is also advised that you follow the sequence of modules and questions which is there on our website. 
          </p>
          <p>Keep practicing more and more problems daily. Meditate enough on each step of each problem.
          </p>
          <p>All the best for an exciting future!
          </p>
          <p>Happy Coding!</p>
       </div>

          <div class="article-tags">
          <div class="tag"> Graph    </div>
          <div class="tag">  Advanced Data Structure   </div>
          <div class="tag">    Recursion    </div>
          <div class="tag">  Array Lists  </div>
          <div class="tag"> Has Path  </div>
            </div>
        <div class="author">
          <div class="sub-heading-2">Author:
                <span> Nikita Aggarwal

                </span>
          </div>
        </div>
        <div class="share-options">
            <p class="share-options-heading">Share this article</p>
            <div class="">
                <div class="span"><i class="fa fa-facebook"></i>
                    <p class="social-media-name">Facebook</p>
                </div>
                <div class="span"><i class="fa fa-twitter"></i>
                    <p class="social-media-name">Twitter</p>
                </div>
                <div class="span"><i class="fa fa-instagram"></i>
                    <p class="social-media-name">Instagram</p>
                </div>
                <div class="span"><i class="fa fa-whatsapp"></i>
                    <p class="social-media-name">Whatsapp</p>
                </div>
                <div class="span"><i class="fa fa-linkedin"></i>
                    <p class="social-media-name">Linkedin</p>
                </div>
            </div>
        </div>
        <div class="lineBreak" style="margin-top: 30px;"></div>
        <div class="img-zoom-div">
            <div class="img-zoom-div-close-btn"><i class="fa fa-times"></i></div>
            <div class="img-zoom-div-img"><img src="" alt="" /></div>
        </div>
      </div>
</div>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link
    href="https://fonts.googleapis.com/css2?family=Asap:ital,wght@1,500&family=Fredoka+One&family=Marck+Script&family=Merienda:wght@700&family=Parisienne&family=Source+Code+Pro:wght@600&family=Varela+Round&display=swap"
    rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.2.0/styles/monokai.css" />
<link
    href="https://fonts.googleapis.com/css2?family=Mulish:wght@300&family=Source+Code+Pro:wght@300&family=Spartan:wght@500&display=swap"
    rel="stylesheet">
</div>


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="./closeZoomImgDiv.js"></script>
    <script src="./bookmark.js"></script>
    <script src="/ace-builds/src-noconflict/ace.js" type="text/javascript" charset="utf-8"></script>
<script>



    var aceEditorInstance = ace.edit( "editor1" );


aceEditorInstance.setTheme("ace/theme/twilight");
// inline must be true to syntax highlight
aceEditorInstance.getSession().setMode( { path: "ace/mode/c_cpp", inline: true } );

// editor 2
  var aceEditorInstance2 = ace.edit( "editor2" );


aceEditorInstance2.setTheme("ace/theme/twilight");
// inline must be true to syntax highlight
aceEditorInstance2.getSession().setMode( { path: "ace/mode/c_cpp", inline: true } );

// editor 3
  var aceEditorInstance3 = ace.edit( "editor3" );


aceEditorInstance3.setTheme("ace/theme/twilight");
// inline must be true to syntax highlight
aceEditorInstance3.getSession().setMode( { path: "ace/mode/c_cpp", inline: true } );
/**
 * Global variable to store the ids of the status of the current dragged ace editor.
 */
window.draggingAceEditor = {};

function makeAceEditorResizable(editor){
    var id_editor = editor.container.id;
    var id_dragbar = '#' + id_editor + '_dragbar';
    var id_wrapper = '#' + id_editor + '_wrapper';
    var wpoffset = 0;
    window.draggingAceEditor[id_editor] = false;

    $(id_dragbar).mousedown(function(e) {
        e.preventDefault();

        window.draggingAceEditor[id_editor] = true;
    
        var _editor = $('#' + id_editor);
        var top_offset = _editor.offset().top - wpoffset;
    
        // Set editor opacity to 0 to make transparent so our wrapper div shows
        _editor.css('opacity', 0);
    
        // handle mouse movement
        $(document).mousemove(function(e){
            var actualY = e.pageY - wpoffset;
            // editor height
            var eheight = actualY - top_offset;
            
            // Set wrapper height
            $(id_wrapper).css('height', eheight);
            
            // Set dragbar opacity while dragging (set to 0 to not show)
            $(id_dragbar).css('opacity', 0.15);
        });
    });
    
    $(document).mouseup(function(e){
        if (window.draggingAceEditor[id_editor])
        {
            var ctx_editor = $('#' + id_editor);
    
            var actualY = e.pageY - wpoffset;
            var top_offset = ctx_editor.offset().top - wpoffset;
            var eheight = actualY - top_offset;
    
            $( document ).unbind('mousemove');
            
            // Set dragbar opacity back to 1
            $(id_dragbar).css('opacity', 1);
            
            // Set height on actual editor element, and opacity back to 1
            ctx_editor.css('height', eheight).css('opacity', 1);
            
            // Trigger ace editor resize()
            editor.resize();

            window.draggingAceEditor[id_editor] = false;
        }
    });
}


makeAceEditorResizable(aceEditorInstance);



</script>

<script>
    var run = document.getElementsByClassName('run')[0]
    var input = document.getElementById('custom_input')
    var language = document.getElementById('language')
    

    run.addEventListener('click', function(){
        
        var unformatted = document.getElementById('editor1').innerText
        var formatted = unformatted.split("\n")
        var final = []
        formatted.forEach(ele=>{
            if(!parseInt(ele))
            final.push(ele)
        
        })
        final = final.join(' ')
        
        var input_text = input.value
        var final_input_text = input_text.split('\n').join(' ')


         
        //language
        const languageValue = language.options[language.selectedIndex].value;
        //const text = language.options[language.selectedIndex].text;
        
        //fetch statement here...

        // fetch('/compileCode',{
        //     method:'post',
        //     headers:{
        //         'Content-Type':'appliation/json'
        //     },
        //     body:JSON.stringify({
        //         input:final_input_text,
        //         code:final,
        //         language:languageValue
        //     })
        // })

             
        alert(JSON.stringify({"code":final, "testcase":final_input_text, "language": languageValue}))
        }
    )
</script>
<script>
    //tabbar btn control
    function tabBar(index){
       
        if(index===0){ 
            // show input textarea
            document.getElementById('custom_output').style.display='none'
            document.getElementById('custom_input').style.display='block'
            document.getElementById('tabBar_0').style.color='rgba(0, 0, 0, 1)'
            document.getElementById('tabBar_1').style.color='rgba(0, 0, 0, 0.479)'
        }
        else{
            // show output textarea
            document.getElementById('custom_output').style.display='block'
            document.getElementById('custom_input').style.display='none'
            document.getElementById('tabBar_1').style.color='rgba(0, 0, 0, 1)'
            document.getElementById('tabBar_0').style.color='rgba(0, 0, 0, 0.479)'
        }
    }
    
</script>
  </body>
</html>
